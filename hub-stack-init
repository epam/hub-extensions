#!/bin/bash -e
# Copyright (c) 2022 EPAM Systems, Inc.
#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.

# shellcheck disable=SC2016,SC2068,SC2086

HUB_HOME="${HUB_HOME:-$(dirname "$0")}"
HUB_WORKDIR="${HUB_WORKDIR:-$(pwd)}"
HUB_EXTENSION="$(basename "$0" | sed 's/-/ /g')"

PATH="$HUB_HOME:$HUB_HOME/bin:$HUB_WORKDIR:$HUB_WORKDIR/bin:$PATH"
export PATH HUB_HOME HUB_EXTENSION

HUB_WORKDIR="$(files abspath "$HUB_WORKDIR")"
export HUB_WORKDIR

hubctl="$(which hubctl 2>/dev/null || true)"
if test -z "$hubctl"; then
  # backward compatibility
  color warn "CLI name 'hub' is deprecated. It will be renamed to 'hubctl' in future releases"
  hubctl="$(which hub 2>/dev/null || true)"
fi
if test -z "$hubctl"; then
  color error "hubctl not found in PATH. Please install hubctl first."
  exit 1
fi

jq="jq -cMr "

hub_state_cli_exist() {
  hubctl state --help >/dev/null 2>&1
}

real_files() {
  for f in $@; do
    if test -f "$f"; then
      echo -n " $f"
    fi
  done
  echo
}

toJson() {
  yq e -o=json "$1"
}

# shellcheck disable=SC2120
usage() {
  cat << EOF
Initializes a brand new stack from existing hubctl file

Usage:
  $HUB_EXTENSION [flags] <state-ref>

Example:
  $HUB_EXTENSION
  $HUB_EXTENSION <state-ref>
  $HUB_EXTENSION -f <path-or-url-hub.yaml>
  $HUB_EXTENSION -f <path-or-url-hub.yaml> --force
  $HUB_EXTENSION <state-ref> -f <path-or-url-hub.yaml> --force

State ref:
  State can be referenced as a file, http, gs url or id (see "hubctl state ls")

EOF

  if test -n "$@"; then
    for req in $@; do
      local init
      init=$(files find-in-path "$req/init")
      if test -n "$init"; then
        $init --help
      fi
    done
  fi

  cat <<EOF

Flags:
  -f, --file string           URL (http) or path to stack definition file (can be repeated multiple times)
  --disable-auto-configure    Turn off configure action on deploy
  --force                     Force to overwrite .env file
  -V, --verbose               Verbose outputs for debug purposes
  -h, --help                  Print this message
EOF
}

ident() {
  sed 's/^/  /'
}

finalize() {
  local rv="$?"
  rm -rf $@
  # if test "$rv" != "0"; then
  #   color e "Finished wih error!"
  # fi
  exit $rv
}

VERBOSE=false
ARGS=$*
HUB_FILES=""
HUB_AUTOCONFIGURE="${HUB_AUTOCONFIGURE:-1}"

while [ "$1" != "" ]; do
  case "$1" in
    -f | --file )
      shift
      HUB_FILES=$(echo "$HUB_FILES $1" | xargs)
      ;;
    # -s | --state )
    #   shift
    #   SOURCE_HUB_STATE="$1"
    #   ;;
    --force )
      HUB_USE_FORCE="1"
      ;;
    --disable-auto-configure )
      HUB_AUTOCONFIGURE="0"
      ;;
    -V | --verbose )
      VERBOSE=true
      ;;
    -h | --help )
      usage
      exit 0
      ;;
    * )
      if test -n "$SOURCE_HUB_STATE"; then
        color e "Error; unknown option $1"
        exit 1
      else
        SOURCE_HUB_STATE="$1"
      fi
      ;;
  esac
  shift
done

if $VERBOSE; then
  set -x
fi

if test -z "$HUB_FILES" -a -f "hub.yaml"; then
  HUB_FILES="hub.yaml"
fi

if test -f "$HUB_WORKDIR/.env" -a -z "$HUB_USE_FORCE"; then
  color error "Error: Stack has been already initialized"
  cat << EOF

Reason: .env file already exists

If this is your intention: try to run the same command with --force flag

EOF
    exit 1
fi

if test -z "$HUB_FILES"; then
  cat << EOF | color e

Error: cannot find hubfile(s)

Example:
  $HUB_EXTENSION -f hub.yaml

EOF
  exit 1
fi

TEMP_DIR=$(mktemp -d || exit 2)
mkdir -p "$TEMP_DIR"
trap 'finalize $TEMP_DIR' EXIT

temp_file() {
  echo "$TEMP_DIR/$(head -c 32 < /dev/urandom | base64 | tr -dc '[:lower:]')"
}

DOT_ENV="$(temp_file)"
KNOWN_URLS=""
EXPANDED=""
export DOT_ENV

expand_hub_files() {
  local f included local_file
  for f in $@; do
    if grep -q "$f" <<< "$EXPANDED"; then
      continue
    fi
    if test -f "$f"; then
      EXPANDED=$(echo "$EXPANDED $f" | xargs)
      echo "* Checking $f"

      included="$(yq e '.extensions.include.[] | select(.)' "$f")"
      if test -n "$included"; then
        expand_hub_files $included
      fi
      continue
    fi
    # is url
    if echo "$f" | grep -e '^https\?://' >/dev/null 2>&1; then
      local_file="$HUB_WORKDIR/$(basename "$f")"
      if test ! -f "$local_file"; then
        files download "$f" "$local_file"
        KNOWN_URLS=$(dirname $f | xargs)
      fi
      expand_hub_files "$local_file"
      continue
    fi

    for url in $KNOWN_URLS; do
      # shellcheck disable=SC2001
      if files download "$url/$1" "$HUB_WORKDIR/$1"; then
        expand_hub_files "$HUB_WORKDIR/$1"
        break
      fi
    done

    if test ! -f "$f"; then
      echo "Error: $f not found!"
      exit 1
    fi
  done
}

update_symlink() {
  if test -L "$2"; then
    if test "$(readlink -n "$2")" != "$1"; then
      unlink "$2"
    fi
  fi
  if test ! -f "$2"; then
    echo "* Updating symlink: .env"
    ln -sf "$1" "$2"
  fi
}

componentDir() {
  $jq --arg 'comp' "$1" '.[] | select(.name==$comp).source?.dir | select(.)'
}

componentSourceRepo() {
  $jq--arg 'src' "$1" --arg 'comp' "$2" '.[] | select(.name==$comp).source?[$src]?.remote | select(.)'
}

componentSourceSubdir() {
  $jq --arg 'src' "$1" --arg 'comp' "$2" '.[] | select(.name==$comp).source?[$src]?.subDir | select(.)'
}

componentSourceRef() {
  $jq --arg 'src' "$1" --arg 'comp' "$2" '.[] | select(.name==$comp).source?[$src]?.ref | [select(.)]+["__auto__"] | [ .[] | select(.!= "")][0]'
}

getParamFromState() {
  hubctl explain "$1" --json | $jq --arg "param" "$2" '.stackParameters[$param] | select(.)'
}

getParamValueByEnvVar() {
  param="$(params envvar "$2" | jq -cMr '.name')"
  if test -n "$param"; then
    getParamFromState "$1" "$param"
  fi
}

if test -n "$SOURCE_HUB_STATE"; then
  echo "Initializing stack from: $SOURCE_HUB_STATE"
else
  echo "Initializing a new stack"
fi
echo "* Using working directory: $HUB_WORKDIR"
if test -L "$HUB_WORKDIR/.env"; then
  echo "* Unlinking .env"
  unlink "$HUB_WORKDIR/.env"
elif test -f "$HUB_WORKDIR/.env" ; then
  echo "* Removing .env"
  rm -rf "$HUB_WORKDIR/.env"
fi

expand_hub_files $HUB_FILES
HUB_FILES="$(real_files $EXPANDED)"
export HUB_FILES

# mkdir -p "$HUB_WORKDIR/.hub/env"
# if test -x "$HUB_WORKDIR/.hub/before-init"; then
#   echo "Running before init script..."
#   $HUB_WORKDIR/.hub/before-init
# fi

HUB_STACK_REQUIRES="$(yq e '' $HUB_FILES -o json | jq -cMr 'select(.extensions).extensions | select(.init).init[]')"
for req in $HUB_STACK_REQUIRES; do
  init=$(files find-in-path "$req/init")
  if test -x "$HUB_WORKDIR/$req"; then
    echo -n "Running init script "
    color h "$req"
    $HUB_WORKDIR/$req $ARGS
  elif test -n "$init"; then
    echo -n "Initializing "
    color h "$req"
    $init $ARGS
  else
    color w "Cannot find neither init script $req neither extension $req/init"
  fi
done

# TODO: remove when hub-extensions packaging will be resolved
if test -n "$SOURCE_HUB_STATE"; then
  # backward compatibility for users who have not installed new hub-state extension
  if hub_state_cli_exist; then
    _state="$($hubctl state show "$SOURCE_HUB_STATE" -o json | $jq '.stateLocation.uri | select(.)')"
    if test -n "$_state"; then
      echo "Found state file: $_state"
      SOURCE_HUB_STATE="$_state"
    fi
  fi
fi

if test -n "$SOURCE_HUB_STATE"; then
  echo "Checking hubctl state"
  for state in $(echo "$SOURCE_HUB_STATE" |tr ',' ' '); do
    temp="$(temp_file)"
    if test -f "$state"; then
      echo "* State file $state: exist"
      HUB_STATE="$HUB_STATE $state"
      #HACK: this is less invasive to the existing code
      cat "$state" > "$temp"
    elif echo "$state" | grep -e '^https\?://' >/dev/null 2>&1; then
      echo -n "* Downloading from: $state... "
      if test ! -f "$temp"; then
        files download "$state" "$temp"
      fi
      echo "done"
    elif echo "$state" | grep -e '^gs\?://' >/dev/null 2>&1; then
      echo -n "* Downloading from: $state... "
      gsutil -q cp "$state" "$temp"
      echo "done"

      state_name="$($hubctl explain "$temp" --json | $jq '.meta.name | select(.)')"
      state_status="$($hubctl explain "$temp" --json | $jq '.status | select(.)')"
      echo "  Downloaded state: $state_name (status: $state_status)"
      state_msg="$($hubctl explain "$temp" --json | $jq '.message | select(.)')"
      if test -n "$state_msg"; then
        echo "  Message: $state_msg"
      fi
    else
      color e "Error: file not found $state"
      exit 13
    fi
    HUB_DOMAIN_NAME=$(getParamFromState "$temp" "dns.domain")
    if test -z "$HUB_DOMAIN_NAME"; then
      HUB_DOMAIN_NAME="$(getParamValueByEnvVar "$temp" "HUB_DOMAIN_NAME")"
      if test -z "$HUB_DOMAIN_NAME"; then
        HUB_DOMAIN_NAME="$(getParamValueByEnvVar "$temp" "HUB_STACK_NAME")"
      fi
    fi
    if test -n "$HUB_DOMAIN_NAME"; then
      echo "* Discovered stack name: $HUB_DOMAIN_NAME"
      DOT_ENV="$HUB_WORKDIR/.hub/env/$HUB_DOMAIN_NAME.env"
      echo "  Creaging .hub/env/$HUB_DOMAIN_NAME.env"
      mkdir -p "$(dirname "$DOT_ENV")"
      touch "$DOT_ENV"
      export DOT_ENV
      local_file="$HUB_WORKDIR/.hub/$HUB_DOMAIN_NAME.state"
      if test -f "$local_file"; then
        echo "  State file exist: .hub/$HUB_DOMAIN_NAME.state"
      else
        files copy "$temp" "$local_file"
      fi
      HUB_STATE="$HUB_STATE $local_file $state"
    else
      echo "  Moving on"
    fi
  done
elif test -z "$(params -f "$HUB_FILES" envvar HUB_DOMAIN_NAME)" \
       -a -z "$(params -f "$HUB_FILES" envvar HUB_STACK_NAME)"; then
  echo "Checking hubctl files for domain name parameters"
  HUB_DOMAIN_NAME="$(params -f "$HUB_FILES" value "dns.domain")"
  HUB_STACK_NAME="$(params -f "$HUB_FILES" value "dns.name")"
  if test -z "$HUB_DOMAIN_NAME" -a -n "$HUB_STACK_NAME"; then
    HUB_DOMAIN_NAME="$HUB_STACK_NAME"
  elif test -n "$HUB_DOMAIN_NAME" -a -z "$HUB_STACK_NAME"; then
    HUB_STACK_NAME="$(echo "$HUB_DOMAIN_NAME" | cut -d "." -f1)"
  fi
  if test -n "$HUB_DOMAIN_NAME"; then
    echo "* Using domain name: $HUB_DOMAIN_NAME"
    dotenv set "HUB_DOMAIN_NAME" "$HUB_DOMAIN_NAME"
    export HUB_DOMAIN_NAME
  fi
  export DOT_ENV
  if test -n "$HUB_STACK_NAME"; then
    echo "* Using stack name: $HUB_STACK_NAME"
    dotenv set "HUB_STACK_NAME" "$HUB_STACK_NAME"
    export HUB_DOMAIN_NAME
  fi
fi
export HUB_STATE

if test -n "$HUB_STATE"; then
  echo "* Checking environment variables from state"
  for env in $(params listenv -f "$HUB_FILES"); do
    param=$(params envvar "$env" | $jq '.name')
    if test -z "$param"; then
      continue
    fi
    for state in $HUB_STATE; do
      if test ! -f $state; then
        continue
      fi

      state_val=$(getParamFromState "$state" "$param")
      if test -n "$state_val"; then
        dotenv set "$env" "$state_val"
        if ! dotenv contains "$env"; then
          echo "  Saving $env to .env file"
        fi
      fi
    done
  done
  # shellcheck disable=SC2046
  eval $(dotenv export -f "$DOT_ENV")
fi

GIT_OPTS="--quiet"
if $VERBOSE; then
  GIT_OPTS=""
fi

echo "Checking components"
for hubfile in $HUB_FILES; do
  if test ! -f $hubfile; then
    color warn "* Warning: skipping $hubfile due to not found"
    continue
  fi
  hubfile_dir="$(dirname "$(files abspath "$hubfile")")"
  components="$(toJson "$hubfile" | $jq '.components | select(.)' -)"
  for comp in $(echo "$components" | $jq '.[].name | select(.)'); do
    echo -n "* component $comp: "
    comp_dir=$(echo $components | componentDir "$comp")
    if test -d "$hubfile_dir/$comp_dir"; then
      echo "exist"
      continue
    fi
    echo "fetching"

    git_repo=$(echo $components | componentSourceRepo "git" "$comp")
    if test -n "$git_repo"; then
      subdir=$(echo $components | componentSourceSubdir "git" "$comp")
      ref=$(echo $components | componentSourceRef "git" "$comp")
      temp_dir=$(temp_file)
      echo "  Retrieving from git source repository"
      echo "  Running: git clone $git_repo"
      mkdir -p "$temp_dir";
      git clone $GIT_OPTS "$git_repo" "$temp_dir" >/dev/null
      (
        cd "$temp_dir";
        git config advice.detachedHead "false" >/dev/null
        head="$(git rev-parse --abbrev-ref HEAD)";
        echo -n "  Using ref: ";
        if test "$ref" = "__auto__"; then
          color b "$head";
        else
          color b "$ref";
          if test "$head" != "$ref"; then
            git fetch $GIT_OPTS --all --tags >/dev/null;
            git checkout $GIT_OPTS "$ref" >/dev/null;
          fi
        fi
      )
      echo "  Saving component: $comp_dir"
      mkdir -p "$hubfile_dir/$comp_dir"
      cp -rf "$temp_dir/$subdir/." "$hubfile_dir/$comp_dir"
      continue
    fi

    gcp_repo=$(echo $components | componentSourceRepo "gcp" "$comp")
    if test -n "$gcp_repo"; then
      subdir=$(echo $components | componentSourceSubdir "gcp" "$comp")
      ref=$(echo $components | componentSourceRef "gcp" "$comp")
      temp_dir=$(temp_file)
      echo "  Retrieving from gcp source repository"
      echo "  Running: gcloud source repos clone $gcp_repo"
      gcloud --no-user-output-enabled source repos clone "$gcp_repo" "$temp_dir"
      (
        cd "$temp_dir";
        head="$(git rev-parse --abbrev-ref HEAD)";
        echo -n "  Using ref: ";
        if test "$ref" = "__auto__"; then
          color b "$head";
        else
          color b "$ref";
          if test "$head" != "$ref"; then
            git fetch $GIT_OPTS --all --tags >/dev/null;
            git checkout $GIT_OPTS "$ref" -b "$ref" >/dev/null;
          fi
        fi
      )
      echo "  Saving component: $comp_dir"
      mkdir -p "$HUB_WORKDIR/$comp_dir"
      cp -rf "$temp_dir/$subdir/." "$HUB_WORKDIR/$comp_dir"
      continue
    fi
  done
done
dotenv set "HUB_AUTOCONFIGURE" "$HUB_AUTOCONFIGURE"
dotenv set "HUB_FILES" "$HUB_FILES"
dotenv set "HUB_WORKDIR" "$HUB_WORKDIR"
dotenv set "HUB_TTY" "false"
if test -n "$HUB_STATE"; then
  dotenv set "HUB_STATE" "$(echo "$HUB_STATE" | xargs | tr ' ' ',')"
fi
echo "Saving configuration"
temp="$(temp_file)"
HUB_DOMAIN_NAME=$(dotenv -f "DOT_ENV" get "HUB_DOMAIN_NAME" --default "$HUB_DOMAIN_NAME")
dotenv merge -f "$DOT_ENV" -f ".hub/env/$HUB_DOMAIN_NAME.env" > "$temp"
echo "* Saving configuration to .hub/env/$HUB_DOMAIN_NAME.env"
files copy "$temp" "$HUB_WORKDIR/.hub/env/$HUB_DOMAIN_NAME.env" | ident
update_symlink "$HUB_WORKDIR/.hub/env/$HUB_DOMAIN_NAME.env" "$HUB_WORKDIR/.env"

# if test -x "$HUB_WORKDIR/.hub/after-init"; then
#   export DOT_ENV="$HUB_WORKDIR/.hub/env/$HUB_DOMAIN_NAME.env"
#   color w "Deprecated functionality: after-init will be removed "
#   $HUB_WORKDIR/.hub/after-init
# fi
cat << EOF

Stack has been initialized!

EOF

if test "$HUB_AUTOCONFIGURE" = "0"; then
  cat << EOF | color g
Next step: apply deployment configuration

Run:
  hubctl stack configure

For more details:
  hubctl stack configure --help

EOF
else
  cat << EOF | color g
Next step: start deploy or undeploy operations

Run:
  hubctl stack deploy
or:
  hubctl stack undeploy

For more details:
  hubctl stack deploy --help
  hubctl stack undeploy --help

EOF
fi
